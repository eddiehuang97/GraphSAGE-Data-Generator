## Analyzing GraphSAGE on Large Graphs

### Overview

GraphSAGE source code copied directly from William Leif's [Github repository](https://github.com/williamleif/GraphSAGE), modified slightly to decrease memory consumption. Additionally, includes a script that can be used to generate data in the example_data folder.

### Usage

To generate data to test, simply run the following shell script:

	./generate_data.sh --nodes=[int] --edges=[int] --prefix=[string]

If arguments are not specified, the script will default to 1000 nodes, 10 edges, and a prefix of "data". Note that the script to run unsupervised learning assumes a prefix of "data" so I don't recommend changing this prefix.

To run unsupervised learning, run the following command:

	./example_unsupervised.sh
	
If you wish to change these settings, copy paste the one line from the above script and make the necessary changes to the command line arguments.

### Data Format

**<train_prefix>-G.json**

Contains basically all necessary info about every node. 

Defines the options (e.g. is the graph directed). "nodes" defines all the properties of each node, aside from the edges from that  particular node. "feature" defines the feature vector. "label" defines which of the 121 classes that particular node is a member of. "test" defines whether a node is used in the test dataset, and "val" defines whether a node is used in the validation dataset. There is approximately a 4:1 ratio between training ("test" and "val" are both false) and validation ("test" is false, "val" is true) data. The "id" can be an int, or a string.

"links" defines all the edges. train_removed and test_removed are used for dynamic edge removal by GraphSAGE. The target and source define which nodes an edge is between. In the example data, the graph is undirected, so which node is the target and source doesn't matter, but for directed graphs, this matters more.

A full format is listed below:

	{
		"directed": boolean,
		{"name": "disjoint_union( ,  )"}
		"nodes": 
		{
			"test": boolean,
			"id": int/string
			"feature": float[100],
			"val": boolean,
			"label": int[121]
		}[num_nodes],
		"links":
		{
			"test_removed": boolean,
			"train_removed": boolean,
			"target": int,
			"source": int
		}[num_edges],
		"multigraph": boolean
	}

**<train_prefix>-id_map.json**

Maps ids to integers. For the example data, simply the integer version of the string. Implemented as JSON key-value pairs with each string acting as the key and its corresponding int id acting as the value. Needed to index the feats.npy file as the node corresponding to the feature vector is not explicitly defined.

**<train_prefix>-class_map.json**

Maps each node to its corresponding 121 element class array.

**<train_prefix>-feats.npy** [optional]

Pickled numpy array file that contains a 2D array, in which each row index corresponds to an integer id as defined in the id_map.json file. Within each row, there is a feature vector that contains 100 floating point numbers between 0.0 and 1.0. 

IMPORTANT: If this file is not included, you MUST specify --identity_dim to a positive integer (preferably 100) when running GraphSAGE, otherwise the script will fail to successfully execute.

**<train_prefix>-walks.txt** [optional]

Optional, only used for unsupervised learning. Contains some subset of edges found under "links" in <train_prefix>-G.json, formatted as:

	"[source]/t[target]" (one per line)
	
This file is automatically generated by the data generation script.

### Data Generation Details

Included within the example_data folder is a Python script titled DataGenerator.py that the script calls. I don't recommend running this Python program directly, as in order to improve performance, I write to multiple files within a temporary directory, then concatenate them later on with the shell script as described earlier. Thus, running this Python program directly will result in a temporary directory with a number of split files that must be combined to create a useful file that GraphSAGE can use.